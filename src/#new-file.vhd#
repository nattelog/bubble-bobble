-- The VGA-controller
-- Used the timing values on page 7; http://lslwww.epfl.ch/pages/teaching/cours_lsl/ca_es/VGA.pdf
-- This site gives slight different values? http://martin.hinner.info/vga/timing.html ie sync pulse 2

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
 

entity vga is

  port  ( clk,rst : in  STD_LOGIC;
        vga_red : out STD_LOGIC_VECTOR(2 downto 0);
        vga_green : out STD_LOGIC_VECTOR(2 downto 0);
    	vga_blue : out STD_LOGIC_VECTOR(1 downto 0);
    	h_sync : out STD_LOGIC;
    	v_sync : out STD_LOGIC
        );

end vga;

architecture behavioral of vga is

-- ************
-- **  VGA   ** 
-- ************

    signal h_count : integer range 0 to 799; -- 40 ns per pixel/count
    signal v_count : integer range 0 to 524; -- 25 MHz has period of 40 ns
    signal clk_timer : integer range 0 to 3; -- Our clock is 100 MHz => Wait 4
                                             -- ticks

-- ************
-- **  GMEM  **
-- ************

    type gm_t is array(0 to 479) of STD_LOGIC_VECTOR(3839 downto 0);
  
    type tile_t is array(0 to 15) of STD_LOGIC_VECTOR(15 downto 0);
    
    signal vga_mem0 : gm_t := (
      others => (others => '1')
    );

    signal vga_mem1 : gm_t := (
      others => (others => '1')
    );
    
    signal write_mem : gm_t := (
      others => (others => '1')
    );
    
    signal read_mem : gm_t  := (
      others => (others => '1')
    );
    
    signal tile_mem : gm_t  := (
      others => (others => '1')
    );
    
    signal tile_block : gm_t  := (
      others => (others => '0');
    );

    signal g_mux : std_logic;
    signal read_y : integer range 0 to 639;
    signal read_x : integer range 0 to 479;
    signal read_byte : std_logic_vector(7 downto 0);
    signal write_y : integer range 0 to 639;
    signal write_x : integer range 0 to 479;
    signal write_byte : std_logic_vector(7 downto 0);
    signal paint_step : std_logic;
    
    signal x_pos : integer range 0 to 639;
    signal y_pos : integer range 0 to 479;
    

-- *******************
-- ** SPRITES & MAP **
-- *******************
    type map_t is array(0 to 29) of STD_LOGIC_VECTOR(39 downto 0);
    signal game_map : map_t := (
    "1111111111111110001111111000111111111111",
    "1111111111111110001111111000111111111111",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1100000000000000000000000000000000000011",
    "1111111111111110001111111000111111110111",
    "1111111111111110001111111000111111110111");

begin

-- **************
-- **   VGA    **
-- **************

process (clk, rst, clk_timer) -- Timer
begin
  if rising_edge(clk) then
    if rst = '1' or clk_timer = 3 then
      clk_timer <= 0;
    else
      clk_timer <= clk_timer + 1;
    end if;
  end if;
end process;

process (clk, rst, h_count, v_count, clk_timer)  -- Counter v_count, h_count
begin
  if rising_edge(clk) then
    if rst = '1' then
      h_count <= 0;
      v_count <= 0;
    elsif v_count < 480 and clk_timer = 3 then
      if h_count < 799 then
        h_count <= h_count + 1;
      else
        h_count <= 0;
	v_count <= v_count + 1;
      end if;
    elsif v_count = 524 and clk_timer = 3 then
	v_count <= 0;
    elsif clk_timer = 3 then
        v_count <= v_count + 1;
    end if;
  end if;
end process;

process (clk, rst, h_count) -- Generate horizontal sync pulse
begin
  if rising_edge(clk) then
    if rst = '1' then
      h_sync <= '0';
    elsif h_count = 658 and clk_timer = 3 then
      h_sync <= '1';
    elsif h_count = 754 and clk_timer = 3 then
      h_sync <= '0';
    end if;
  end if;
end process;

process (clk, rst, v_count) -- Generate vertical sync pulse
begin
  if rising_edge(clk) then
    if rst = '1' then
      v_sync <= '0';
    elsif v_count = 493 and clk_timer = 3 then
      v_sync <= '1';
    elsif v_count = 494 and clk_timer = 3 then
      v_sync <= '0';
    end if;
  end if;
end process;

process(clk, rst)
begin
  if rising_edge(clk) then
    if rst = '1' then
      vga_red <= "000";
      vga_green <= "000";
      vga_blue <= "00";
    elsif v_count < 479 and h_count < 639 and clk_timer = 3 then
      --vga_red <= pixel(7 downto 5);
      --vga_green <= pixel(4 downto 2);
      --vga_blue <= pixel(1 downto 0);
    end if;
  end if;
end process;


-- **************
-- **   GMEM   **
-- **************

process(clk, rst, g_mux) -- Mux memory
begin
  if rising_edge(clk) then
    if rst = '1' then
      -- reset
    elsif g_mux = '0' then
      read_mem <= vga_mem0;
      vga_mem1 <= write_mem;
    elsif g_mux = '1' then
      read_mem <= vga_mem1;
      vga_mem0 <= write_mem;
    end if;
  end if;
end process;

process(clk, rst, read_x, read_y) -- Read byte on coordinate
begin
  if rising_edge(clk) then
    if rst = '1' then
      read_x <= 0;
      read_y <= 0;
    else
      read_byte <= read_mem(read_y)(7 + read_x * 8 downto read_x * 8); 
    end if;
  end if;
end process;

process(clk, rst, write_x, write_y, write_byte) -- Write byte on coordinate
begin
  if rising_edge(clk) then
    if rst = '1' then
      write_x <= 0;
      write_y <= 0;
      write_byte <= X"FF";
    else
      write_mem(write_y)(7 + write_x * 8 downto write_x * 8) <= write_byte;
    end if;
  end if;
end process;

process(clk, rst, x_pos, y_pos, tile_mem)
variable x : integer := -1;
variable y : integer := 0;
begin
  if rising_edge(clk) then
    if rst='1' then
      -- reset
    else
      x := x + 1;
      if x < 16 then
        write_byte <= tile_mem(y)(7+x*8 downto x*8);
      else if y < 16 then
        
      else 
        -- done
    end if;
  end if;
end process;       
end;
